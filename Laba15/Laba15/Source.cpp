#include <iostream>
#include <string>
#include <map>
using namespace std;

template<typename T>
class Stack {//стек для хранения состояний
private:

	template<typename T>
	struct el {
		T data;
		el<T>* prev;
	};
	el<T>* top;//вершина
	int size;//кол-во  элементов

public:

	Stack() {//конструктор
		top = nullptr;
		size = 0;
	}
	void push(T a) {//добавить элемент
		if (top == nullptr) {//если первый
			el<T>* n = new el<T>;
			n->data = a;
			n->prev = nullptr;
			top = n;
			size++;
		}
		else {
			el<T>* n = new el<T>;
			n->data = a;
			n->prev = top;
			top = n;
			size++;
		}
	}
	T pop() {//извлечь элемент
		if (top != nullptr) {
			T ret = top->data;
			el<T>* n = top->prev;
			delete top;
			top = n;
			size--;
			return ret;
		}
	}
};

bool prove_token(char a) {//проверить, принадлежит ли символ а токенам
	if (a == '+' || a == '-' || a == '*' || a == '/' || a == '(' || a == ')' || a == '$' || a == 'i' || a == 'n')
		return true;
	else
		return false;
}

int main() {
	setlocale(LC_ALL, "Russian");
	
	//храним таблицу ACTION в виде map, где ключ - номер состояния и символ, значение - какое действие выполнить (е - ошибка, i - сдвиг и в какое состояние перейти, ri - применить сверстку по правилу i)
	//например, {"12+","r9"} означает, что находясь в состоянии 12 по символу + необходимо выполнить сверстку по правилу 9
	map<string, string> ACTION = { {"0+","e"},  {"0-","e"},  {"0*","e"},  {"0/","e"},  {"0(","3"}, {"0)","e"},  {"0$","e"},  {"0i","1"},  {"0n","2"},
								   {"1+","r7"}, {"1-","r7"}, {"1*","r7"}, {"1/","r7"}, {"1(","e"}, {"1)","r7"}, {"1$","r7"}, {"1i","e"},  {"1n","e"},
								   {"2+","r8"}, {"2-","r8"}, {"2*","r8"}, {"2/","r8"}, {"2(","e"}, {"2)","r8"}, {"2$","r8"}, {"2i","e"},  {"2n","e"},
								   {"3+","e"},  {"3-","e"},  {"3*","e"},  {"3/","e"},  {"3(","3"}, {"3)","e"},  {"3$","e"},  {"3i","1"},  {"3n","2"},
								   {"4+","8"},  {"4-","9"},  {"4*","e"},  {"4/","e"},  {"4(","e"}, {"4)","e"},  {"4$","r0"}, {"4i","e"},  {"4n","e"},
								   {"5+","r3"}, {"5-","r3"}, {"5*","10"}, {"5/","11"}, {"5(","e"}, {"5)","r3"}, {"5$","r3"}, {"5i","e"},  {"5n","e"},
								   {"6+","r6"}, {"6-","r6"}, {"6*","r6"}, {"6/","r6"}, {"6(","e"}, {"6)","r6"}, {"6$","r6"}, {"6i","e"},  {"6n","e"},
								   {"7+","8"},  {"7-","9"},  {"7*","e"},  {"7/","e"},  {"7(","e"}, {"7)","12"}, {"7$","e"},  {"7i","e"},  {"7n","e"},
								   {"8+","e"},  {"8-","e"},  {"8*","e"},  {"8/","e"},  {"8(","3"}, {"8)","e"},  {"8$","e"},  {"8i","1"},  {"8n","2"},
								   {"9+","e"},  {"9-","e"},  {"9*","e"},  {"9/","e"},  {"9(","3"}, {"9)","e"},  {"9$","e"},  {"9i","1"},  {"9n","2"},
								   {"10+","e"}, {"10-","e"}, {"10*","e"}, {"10/","e"}, {"10(","3"},{"10)","e"}, {"10$","e"}, {"10i","1"}, {"10n","2"},
								   {"11+","e"}, {"11-","e"}, {"11*","e"}, {"11/","e"}, {"11(","3"},{"11)","e"}, {"11$","e"}, {"11i","1"}, {"11n","2"},
								   {"12+","r9"},{"12-","r9"},{"12*","r9"},{"12/","r9"},{"12(","e"},{"12)","e"}, {"12$","r9"},{"12i","r9"},{"12n","e"},
								   {"13+","r1"},{"13-","r1"},{"13*","10"},{"13/","11"},{"13(","e"},{"13)","r1"},{"13$","r1"},{"13i","e"}, {"13n","e"},
								   {"14+","r2"},{"14-","r2"},{"14*","10"},{"14/","11"},{"14(","e"},{"14)","r2"},{"14$","r2"},{"14i","e"}, {"14n","e"},
								   {"15+","r4"},{"15-","r4"},{"15*","r4"},{"15/","r4"},{"15(","e"},{"15)","r4"},{"15$","r4"},{"15i","e"}, {"15n","e"},
								   {"16+","r5"},{"16-","r5"},{"16*","r5"},{"16/","r5"},{"16(","e"},{"16)","r5"},{"16$","r5"},{"16i","e"}, {"16n","e"} };
	
	//храним таблицу GOTO в виде map, где ключ - состояние и значение, полученное в результате сверстки, значение - в какое состояние перейти (е - ошибка)
	//например {"0E","4"} означает, что если в результате сверстки мы получили Е и оказались в состоянии 0, то нужно перейти в состояние 4
	map<string, string> GOTO = { {"0E","4"}, {"0T","5"}, {"0F","6"},
							     {"1E","e"}, {"1T","e"}, {"1F","e"},
							     {"2E","e"}, {"2T","e"}, {"2F","e"},
							     {"3E","7"}, {"3T","5"}, {"3F","6"},
							     {"4E","e"}, {"4T","e"}, {"4F","e"},
							     {"5E","e"}, {"5T","e"}, {"5F","e"},
							     {"6E","e"}, {"6T","e"}, {"6F","e"},
							     {"7E","e"}, {"7T","e"}, {"7F","e"},
							     {"8E","e"}, {"8T","13"},{"8F","6"},
							     {"9E","e"}, {"9T","14"},{"9F","6"},
							     {"10E","e"},{"10T","e"},{"10F","15"},
							     {"11E","e"},{"11T","e"},{"11F","16"},
							     {"12E","e"},{"12T","e"},{"12F","e"},
							     {"13E","e"},{"13T","e"},{"13F","e"},
							     {"14E","e"},{"14T","e"},{"14F","e"},
	     					     {"15E","e"},{"15T","e"},{"15F","e"},
  		    				     {"16E","e"},{"16T","e"},{"16F","e"} };

	//rules_ret хранит, какой символ мы получим, если применем правило ri
	//например, при применении правила r4: T->T*F мы получаем символ T 
	map<string, string> rules_ret = { {"r1","E"},{"r2","E"},{"r3","E"},
									  {"r4","T"},{"r5","T"},{"r6","T"},
									  {"r7","F"},{"r8","F"},{"r9","F"} };

	cout << "Введите строку\n";
	string input;//вводимая строка
	cin >> input;
	int pos = 0;//номер текущего символа

	Stack<string> stack;//стек для хранения состояний
	stack.push("0");//первое состояние - 0

	bool finish = false;
	while (!finish) {//пока не конец

		string s = stack.pop();//запоминаем сотояние из верхушки стека
		stack.push(s);

		char a = input[pos];//берем текущий символ

		if (prove_token(a)) {//проверяем, принадлежит ли символ токенам

			string action = s;
			action.push_back(a);//action = состояние + символ, например, если извлекли из стека состояние 5 и текущий символ -, то action="5-"

			//если нужно применить сдвиг
			if (ACTION[action] == "1" || ACTION[action] == "2" || ACTION[action] == "3" || ACTION[action] == "4" || ACTION[action] == "5" || ACTION[action] == "6" || ACTION[action] == "7" || ACTION[action] == "8" || ACTION[action] == "9" || ACTION[action] == "10" || ACTION[action] == "11" || ACTION[action] == "12" || ACTION[action] == "13" || ACTION[action] == "14" || ACTION[action] == "15" || ACTION[action] == "16") {
				stack.push(ACTION[action]);//заносим состояние в стек
				pos++;//переходим к следующему символу
			}
			//если нужно применить правила типа E->E+T, E->E-T, T->T*F, T->T/F
			else if (ACTION[action] == "r1" || ACTION[action] == "r2" || ACTION[action] == "r4" || ACTION[action] == "r5") {
				stack.pop();//извлекаем из стека 2 состояния
				stack.pop();
			}
			//если нужно применить правило типа E->T, T->F, F->id, F->num
			else if (ACTION[action] == "r3" || ACTION[action] == "r6" || ACTION[action] == "r7" || ACTION[action] == "r8") {
				string ret = rules_ret[ACTION[action]];//смотрим, какой символ получим в результате применения правила
				stack.pop();//извлекаем одно состояние

				string goto1 = stack.pop();//запоминаем верхушку стека состояний
				stack.push(goto1);

				goto1.append(ret);//goto1 - по какому значению будет происходить поиск состояния в таблице GOTO (например, "12e")

				//ищем состояние, в которое надо перейти
				if (GOTO[goto1] == "e") {//если ошибка
					cout << "Ошибка\n";
					exit(0);
				}
				else
					stack.push(GOTO[goto1]);//если состояние существует, заносим его в стек
			}
			//если правило F->(E)
			else if (ACTION[action] == "r9") {
				string ret = rules_ret[ACTION[action]];//смотрим, какой символ получим в результате применения правила
				stack.pop();//извлекаем 3 состояния из стека
				stack.pop();
				stack.pop();

				string goto1 = stack.pop();//запоминаем верхушку
				stack.push(goto1);

				goto1.append(ret);//goto1 - по какому значению будет происходить поиск состояния в таблице GOTO

				//ищем состояние, в которое надо перейти
				if (GOTO[goto1] == "e") {//если ошибка
					cout << "Ошибка\n";
					exit(0);
				}
				else
					stack.push(GOTO[goto1]);//если существует состояние, заносим его в стек
			}
			//если правило типа E'->E, то программа завершается удачно
			else if (ACTION[action] == "r0") {
				cout << "ОК\n";
				finish = true;
			}
			//если получили, что в результате действия получили ошибку
			else if (ACTION[action] == "e") {
				cout << "Ошибка\n";
				exit(0);
			}
		}
		else {//если такого токена не существует
			cout << "Ошибка\n";
			exit(0);
		}
	}
	system("pause");
	return 0;
}